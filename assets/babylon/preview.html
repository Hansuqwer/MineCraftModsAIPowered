<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>3D Preview</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Minecraft', monospace;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <div id="loading">Loading 3D preview...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        // Get parameters from URL (Flutter will pass these)
        const urlParams = new URLSearchParams(window.location.search);
        const itemType = urlParams.get('type') || 'sword';
        const itemColor = urlParams.get('color') || 'blue';
        const itemGlow = urlParams.get('glow') || 'none';
        const itemSize = urlParams.get('size') || 'medium';

        console.log('ðŸŽ¨ Creating 3D preview for:', itemType, itemColor, itemGlow);

        // Initialize Babylon.js
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = function() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0, 0, 0, 0); // Transparent

            // Camera (arc rotate for touch/mouse rotation)
            const camera = new BABYLON.ArcRotateCamera(
                "camera",
                Math.PI / 4,
                Math.PI / 3,
                5,
                BABYLON.Vector3.Zero(),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 3;
            camera.upperRadiusLimit = 10;
            camera.wheelPrecision = 50;

            // Lighting
            const light1 = new BABYLON.HemisphericLight(
                "light1",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            light1.intensity = 0.7;

            const light2 = new BABYLON.PointLight(
                "light2",
                new BABYLON.Vector3(2, 3, 2),
                scene
            );
            light2.intensity = 0.5;

            // Create the 3D item based on type
            createItem(scene, itemType, itemColor, itemGlow, itemSize);

            // Hide loading message
            document.getElementById('loading').style.display = 'none';

            return scene;
        };

        function createItem(scene, type, color, glow, size) {
            const lowerType = type.toLowerCase();

            // Scale multiplier based on size
            let scale = 1.0;
            if (size === 'tiny') scale = 0.5;
            else if (size === 'small') scale = 0.75;
            else if (size === 'large') scale = 1.5;
            else if (size === 'giant') scale = 2.0;

            // Create based on type
            if (lowerType.includes('sword')) {
                createSword(scene, color, glow, scale);
            } else if (lowerType.includes('helmet') || lowerType.includes('armor')) {
                createHelmet(scene, color, glow, scale);
            } else if (lowerType.includes('dragon')) {
                createDragon(scene, color, glow, scale);
            } else if (lowerType.includes('chair') || lowerType.includes('furniture')) {
                createChair(scene, color, glow, scale);
            } else {
                // Default: cube
                createCube(scene, color, glow, scale);
            }
        }

        function getColor(colorName) {
            const colors = {
                'black': new BABYLON.Color3(0.1, 0.1, 0.1),
                'white': new BABYLON.Color3(0.95, 0.95, 0.95),
                'red': new BABYLON.Color3(0.9, 0.1, 0.1),
                'blue': new BABYLON.Color3(0.1, 0.4, 0.9),
                'green': new BABYLON.Color3(0.1, 0.8, 0.1),
                'yellow': new BABYLON.Color3(0.95, 0.9, 0.1),
                'purple': new BABYLON.Color3(0.6, 0.2, 0.8),
                'pink': new BABYLON.Color3(0.9, 0.4, 0.7),
                'orange': new BABYLON.Color3(0.9, 0.5, 0.1),
                'brown': new BABYLON.Color3(0.4, 0.25, 0.1),
                'gold': new BABYLON.Color3(1.0, 0.84, 0.0),
                'golden': new BABYLON.Color3(1.0, 0.84, 0.0),
                'silver': new BABYLON.Color3(0.75, 0.75, 0.75),
            };
            return colors[colorName.toLowerCase()] || colors['blue'];
        }

        function applyGlow(mesh, glowType, color) {
            if (glowType === 'none') return;

            const glowLayer = new BABYLON.GlowLayer("glow", mesh.getScene());
            glowLayer.intensity = 1.0;

            if (glowType === 'white' || glowType === 'bright') {
                mesh.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            } else if (glowType === 'soft') {
                mesh.material.emissiveColor = color.scale(0.3);
            } else if (glowType === 'pulsing') {
                mesh.material.emissiveColor = color.scale(0.5);
                // Add pulsing animation
                scene.registerBeforeRender(() => {
                    const pulse = (Math.sin(Date.now() * 0.002) + 1) * 0.5;
                    glowLayer.intensity = 0.5 + pulse * 0.5;
                });
            }
        }

        function createSword(scene, colorName, glow, scale) {
            const color = getColor(colorName);

            // Blade (main part)
            const blade = BABYLON.MeshBuilder.CreateBox("blade", {
                width: 0.2 * scale,
                height: 2.5 * scale,
                depth: 0.1 * scale
            }, scene);
            blade.position.y = 0;
            blade.rotation.z = Math.PI / 6; // Angle it

            // Handle
            const handle = BABYLON.MeshBuilder.CreateCylinder("handle", {
                diameter: 0.2 * scale,
                height: 0.6 * scale
            }, scene);
            handle.position.y = -1.5 * scale;
            handle.rotation.z = Math.PI / 6;

            // Guard (cross-guard)
            const guard = BABYLON.MeshBuilder.CreateBox("guard", {
                width: 0.8 * scale,
                height: 0.1 * scale,
                depth: 0.1 * scale
            }, scene);
            guard.position.y = -1.2 * scale;
            guard.rotation.z = Math.PI / 6;

            // Materials
            const bladeMat = new BABYLON.StandardMaterial("bladeMat", scene);
            bladeMat.diffuseColor = color;
            bladeMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            blade.material = bladeMat;

            const handleMat = new BABYLON.StandardMaterial("handleMat", scene);
            handleMat.diffuseColor = new BABYLON.Color3(0.3, 0.2, 0.1);
            handle.material = handleMat;
            guard.material = handleMat;

            // Merge into one
            const sword = BABYLON.Mesh.MergeMeshes([blade, handle, guard], true, true);
            sword.name = "sword";

            applyGlow(sword, glow, color);

            // Slow rotation
            scene.registerBeforeRender(() => {
                sword.rotation.y += 0.01;
            });
        }

        function createHelmet(scene, colorName, glow, scale) {
            const color = getColor(colorName);

            // Dome (top of helmet)
            const dome = BABYLON.MeshBuilder.CreateSphere("dome", {
                diameter: 1.5 * scale,
                segments: 16
            }, scene);
            dome.position.y = 0.2 * scale;
            dome.scaling.y = 0.8; // Flatten slightly

            // Visor
            const visor = BABYLON.MeshBuilder.CreateBox("visor", {
                width: 1.2 * scale,
                height: 0.3 * scale,
                depth: 0.1 * scale
            }, scene);
            visor.position.y = 0 * scale;
            visor.position.z = 0.7 * scale;

            // Material
            const helmetMat = new BABYLON.StandardMaterial("helmetMat", scene);
            helmetMat.diffuseColor = color;
            helmetMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            helmetMat.metallic = 0.8;
            dome.material = helmetMat;
            visor.material = helmetMat;

            const helmet = BABYLON.Mesh.MergeMeshes([dome, visor], true, true);
            helmet.name = "helmet";

            applyGlow(helmet, glow, color);

            scene.registerBeforeRender(() => {
                helmet.rotation.y += 0.01;
            });
        }

        function createDragon(scene, colorName, glow, scale) {
            const color = getColor(colorName);

            // Body
            const body = BABYLON.MeshBuilder.CreateSphere("body", {
                diameter: 1.5 * scale,
                segments: 12
            }, scene);
            body.position.y = 0;
            body.scaling.z = 1.5;

            // Head
            const head = BABYLON.MeshBuilder.CreateSphere("head", {
                diameter: 1.0 * scale,
                segments: 12
            }, scene);
            head.position.z = 1.2 * scale;
            head.position.y = 0.3 * scale;

            // Wings (simplified)
            const wing1 = BABYLON.MeshBuilder.CreateBox("wing1", {
                width: 2.0 * scale,
                height: 0.1 * scale,
                depth: 1.0 * scale
            }, scene);
            wing1.position.x = -1.5 * scale;
            wing1.position.y = 0.5 * scale;
            wing1.rotation.z = Math.PI / 4;

            const wing2 = wing1.clone("wing2");
            wing2.position.x = 1.5 * scale;
            wing2.rotation.z = -Math.PI / 4;

            // Material
            const dragonMat = new BABYLON.StandardMaterial("dragonMat", scene);
            dragonMat.diffuseColor = color;
            body.material = dragonMat;
            head.material = dragonMat;
            wing1.material = dragonMat;
            wing2.material = dragonMat;

            const dragon = BABYLON.Mesh.MergeMeshes([body, head, wing1, wing2], true, true);
            dragon.name = "dragon";

            applyGlow(dragon, glow, color);

            scene.registerBeforeRender(() => {
                dragon.rotation.y += 0.01;
            });
        }

        function createChair(scene, colorName, glow, scale) {
            const color = getColor(colorName);

            // Seat
            const seat = BABYLON.MeshBuilder.CreateBox("seat", {
                width: 1.0 * scale,
                height: 0.2 * scale,
                depth: 1.0 * scale
            }, scene);
            seat.position.y = 0;

            // Back
            const back = BABYLON.MeshBuilder.CreateBox("back", {
                width: 1.0 * scale,
                height: 1.2 * scale,
                depth: 0.2 * scale
            }, scene);
            back.position.y = 0.5 * scale;
            back.position.z = -0.4 * scale;

            // Legs (4)
            const legPositions = [
                {x: -0.4 * scale, z: 0.4 * scale},
                {x: 0.4 * scale, z: 0.4 * scale},
                {x: -0.4 * scale, z: -0.4 * scale},
                {x: 0.4 * scale, z: -0.4 * scale}
            ];

            const legs = [];
            legPositions.forEach((pos, i) => {
                const leg = BABYLON.MeshBuilder.CreateCylinder(`leg${i}`, {
                    diameter: 0.15 * scale,
                    height: 0.8 * scale
                }, scene);
                leg.position.x = pos.x;
                leg.position.y = -0.5 * scale;
                leg.position.z = pos.z;
                legs.push(leg);
            });

            // Material
            const chairMat = new BABYLON.StandardMaterial("chairMat", scene);
            chairMat.diffuseColor = color;
            seat.material = chairMat;
            back.material = chairMat;
            legs.forEach(leg => leg.material = chairMat);

            const chair = BABYLON.Mesh.MergeMeshes([seat, back, ...legs], true, true);
            chair.name = "chair";

            applyGlow(chair, glow, color);

            scene.registerBeforeRender(() => {
                chair.rotation.y += 0.01;
            });
        }

        function createCube(scene, colorName, glow, scale) {
            const color = getColor(colorName);

            const cube = BABYLON.MeshBuilder.CreateBox("cube", {
                size: 1.5 * scale
            }, scene);

            const cubeMat = new BABYLON.StandardMaterial("cubeMat", scene);
            cubeMat.diffuseColor = color;
            cube.material = cubeMat;

            applyGlow(cube, glow, color);

            scene.registerBeforeRender(() => {
                cube.rotation.y += 0.01;
                cube.rotation.x += 0.005;
            });
        }

        // Create scene and start render loop
        const scene = createScene();
        engine.runRenderLoop(() => {
            scene.render();
        });

        // Resize
        window.addEventListener("resize", () => {
            engine.resize();
        });

        console.log('âœ… 3D preview ready!');
    </script>
</body>
</html>
