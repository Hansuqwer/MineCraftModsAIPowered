<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crafta Preview</title>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
<style>
  html,body{margin:0;overflow:hidden;background:#d6f1ff}
  #renderCanvas{width:100vw;height:100vh;touch-action:none;display:block}
  #hud{position:fixed;left:8px;bottom:8px;right:8px;color:#333;font:12px/1.4 system-ui,sans-serif;pointer-events:none;max-height:160px;overflow-y:auto}
  .ok{color:#16a34a}.err{color:#dc2626}.warn{color:#f59e0b}
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="hud"></div>
<script>
(() => {
  const log=(m,c="")=>{const el=document.getElementById("hud"); el.innerHTML+=`<div class="${c}">${m}</div>`; console.log("[HUD]",m);};

  const url = new URL(window.location.href);
  const spec = {
    object:   (url.searchParams.get('object')||'dragon').toLowerCase(),
    theme:    (url.searchParams.get('theme')||'fire').toLowerCase(),
    colors:   (url.searchParams.get('colors')||'red,black,gold').split(','),
    size:     (url.searchParams.get('size')||'medium').toLowerCase(),
    features: (url.searchParams.get('features')||'glowing').split(',')
  };

  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas,true,{preserveDrawingBuffer:true,stencil:true});
  const scene = new BABYLON.Scene(engine);
  scene.clearColor=new BABYLON.Color3(0.85,0.95,1.0);
  scene.ambientColor=new BABYLON.Color3(0.5,0.5,0.5);

  const camera=new BABYLON.ArcRotateCamera("cam",Math.PI/4,Math.PI/3,12,BABYLON.Vector3.Zero(),scene);
  camera.lowerRadiusLimit=4; camera.upperRadiusLimit=30;
  camera.wheelPrecision=40; camera.panningSensibility=0;
  camera.attachControl(canvas,true);

  new BABYLON.HemisphericLight("hemi",new BABYLON.Vector3(0.4,1,0.2),scene).intensity=1.3;
  const sun=new BABYLON.DirectionalLight("sun",new BABYLON.Vector3(-1,-2,-1),scene);
  sun.position=new BABYLON.Vector3(6,15,6); sun.intensity=1.0;

  // ---------- helpers ----------
  const COLORS={
    red:[0.8,0.2,0.2], green:[0.2,0.8,0.2], blue:[0.2,0.2,0.8], gold:[0.8,0.6,0.2],
    black:[0.1,0.1,0.1], white:[0.9,0.9,0.9], gray:[0.5,0.5,0.5], orange:[1,0.5,0.2]
  };
  const color3=(name)=>{const c=COLORS[name]||[0.3,0.3,0.8]; return new BABYLON.Color3(c[0],c[1],c[2]);};

  function createMat(name, glow=false){
    const m=new BABYLON.StandardMaterial(`mat_${name}_${Math.random().toString(36).slice(2)}`,scene);
    m.diffuseColor=color3(name);
    if(glow){ const c=m.diffuseColor; m.emissiveColor=new BABYLON.Color3(c.r*0.4,c.g*0.4,c.b*0.4); }
    m.specularColor = BABYLON.Color3.Black();
    return m;
  }
  function eyeMat(){
    const m=new BABYLON.StandardMaterial("eye_"+Math.random().toString(36).slice(2),scene);
    m.diffuseColor=new BABYLON.Color3(1,0,0); m.emissiveColor=new BABYLON.Color3(1,0,0); m.specularColor=BABYLON.Color3.Black();
    return m;
  }
  function mcTextureMat(pngPath){
    const m=new BABYLON.StandardMaterial("mc_"+Math.random().toString(36).slice(2),scene);
    m.diffuseTexture=new BABYLON.Texture(pngPath,scene);
    m.specularColor=BABYLON.Color3.Black();
    return m;
  }

  // ---------- dragon (improved silhouette + wing flap) ----------
  function buildDragon(opt={}){
    const {colors=['red','black','gold'], size='medium', features=['glowing'], texture=null}=opt;
    const scale=size==='large'?1.5:size==='small'?0.7:1.0;
    const glow=features.includes('glowing');
    const main = texture ? mcTextureMat(texture) : createMat(colors[0],glow);
    const eyes = eyeMat();

    const body = BABYLON.MeshBuilder.CreateCylinder("body",{height:4*scale,diameterTop:1.0*scale,diameterBottom:1.6*scale,tessellation:24},scene);
    body.rotation.x = Math.PI/2; body.position.y=1.4*scale;

    const head = BABYLON.MeshBuilder.CreateSphere("head",{diameterX:1.3*scale,diameterY:1.0*scale,diameterZ:1.6*scale},scene);
    head.position.set(0,1.8*scale,-2.8*scale);

    const tail = BABYLON.MeshBuilder.CreateCylinder("tail",{height:2.8*scale,diameterTop:0.1*scale,diameterBottom:0.7*scale,tessellation:24},scene);
    tail.rotation.x=Math.PI/2; tail.position.set(0,1.2*scale,3.5*scale);

    const wingL = BABYLON.MeshBuilder.CreatePlane("wingL",{width:4*scale,height:2*scale},scene);
    wingL.position.set(-2.3*scale,2.4*scale,-0.5*scale); wingL.rotation.y=Math.PI/3;

    const wingR = wingL.clone("wingR");
    wingR.position.x*=-1; wingR.rotation.y*=-1;

    const eyeL = BABYLON.MeshBuilder.CreateSphere("eyeL",{diameter:0.25*scale},scene);
    const eyeR = eyeL.clone("eyeR");
    eyeL.position.set(-0.35*scale,1.9*scale,-3.3*scale);
    eyeR.position.set(0.35*scale,1.9*scale,-3.3*scale);

    [body,head,tail,wingL,wingR].forEach(m=>m.material=main);
    eyeL.material=eyeR.material=eyes;

    const dragon = BABYLON.Mesh.MergeMeshes([body,head,tail,wingL,wingR,eyeL,eyeR],true,true);
    dragon.name="dragon";

    // wing flap + gentle hover
    let t=0;
    scene.registerBeforeRender(()=>{
      const dt = engine.getDeltaTime()/1000;
      t += dt*3.5;
      dragon.rotation.y += dt*0.5;
      wingL.rotation.z = Math.sin(t)*0.25;
      wingR.rotation.z = -Math.sin(t)*0.25;
      dragon.position.y = 1.2*scale + Math.sin(t*0.5)*0.08;
    });

    return dragon;
  }

  // ---------- entry ----------
  let model = null;
  try{
    if(spec.object==='dragon'){
      // If you add a Minecraft-style atlas later, pass as: texture: 'flutter-asset://assets/textures/dragon_atlas_fire.png'
      model = buildDragon({colors:spec.colors,size:spec.size,features:spec.features});
      log("✅ Dragon built","ok");
    } else {
      // fallback: simple colored box per other objects until their builders are wired
      const m = new BABYLON.StandardMaterial("box",scene);
      m.diffuseColor=color3(spec.colors[0]||'red');
      model = BABYLON.MeshBuilder.CreateBox("box",{size:2},scene); model.material=m;
      log(`⚠️ Fallback box for object: ${spec.object}`,"warn");
    }

    // center camera on the actual mesh
    const bb = model.getBoundingInfo().boundingBox;
    camera.setTarget(bb.centerWorld);

    // notify Flutter (sparkle/TTS)
    if (window?.flutter_inappwebview?.callHandler) {
      window.flutter_inappwebview.callHandler('onModelReady');
    }
  }catch(e){
    log("❌ build error: "+e.message,"err");
  }

  // render loop (delta-time stable)
  engine.runRenderLoop(()=>{ scene.render(); });
  window.addEventListener("resize",()=>engine.resize());

  // Public API so Flutter can update without reloading
  window.applySpec = (json) => {
    try{
      const next=JSON.parse(json);
      window.location.search = new URLSearchParams({
        object: next.object||spec.object,
        theme: next.theme||spec.theme,
        colors: (next.colors||spec.colors).join(','),
        size: next.size||spec.size,
        features: (next.features||spec.features).join(',')
      }).toString();
    }catch(e){ log("applySpec error: "+e.message,"err"); }
  };
})();
</script>
</body>
</html>